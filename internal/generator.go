package internal

import (
	"fmt"
	"go/format"
	"sort"
	"strconv"
	"strings"
)

type Substitution struct {
	key   string
	value string
}

func getKeysSorted(data map[string]string) []string {
	keys := make([]string, 0, len(data))
	for key := range data {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func genFuncImpl(sb *strings.Builder, name string, data map[string]string) bool {
	hasParams := false
	keys := getKeysSorted(data)
	for _, key := range keys {
		strValue := data[key]
		methodName := toPublicName(key)
		params, body := getMethodDef(strValue)
		sb.WriteString(fmt.Sprintf("func (t *%s) %s(%s) string {\n", name, methodName, strings.Join(params, ", ")))
		sb.WriteString(body)
		sb.WriteString("}\n\n")
		if len(params) > 0 {
			hasParams = true
		}
	}
	return hasParams
}

func genFuncSignature(sb *strings.Builder, key string, value string) {
	funcName := toPublicName(key)
	params, _ := getMethodDef(value)
	sb.WriteString(fmt.Sprintf("%s(%s) string\n", funcName, strings.Join(params, ", ")))
}

// GetFuncSignatureId generates a unique identifier for a function signature based on its parameters.
// This is useful to compare generated functions for different locales.
func GetFuncSignatureId(key string, value string) string {
	var sb strings.Builder
	genFuncSignature(&sb, key, value)
	return strings.TrimSpace(sb.String())
}

func GetTranslationImpl(data TomlData, packageName string) ([]byte, error) {
	var sb strings.Builder

	header := fmt.Sprintf(`
	  // Code generated by simple-translate; DO NOT EDIT.
	  package %s
	`, packageName)
	needsFmt := false

	// Write all sections first
	sectionNameToType := make(map[string]string)
	for sectionKey, sectionData := range data.sections {
		sectionName := toPrivateName(sectionKey)
		langName := toPublicName(data.Locale)
		sectionStructName := fmt.Sprintf("Translation%s_%s", langName, sectionName)
		sectionNameToType[sectionName] = sectionStructName

		sb.WriteString(fmt.Sprintf("type %s struct{}\n\n", sectionStructName))
		hasParams := genFuncImpl(&sb, sectionStructName, sectionData)
		if hasParams {
			needsFmt = true
		}
	}

	// Root translations
	langName := toPublicName(data.Locale)
	rootStructName := fmt.Sprintf("Translation%s", langName)
	sb.WriteString(fmt.Sprintf("type %s struct{", rootStructName))
	for sectionName, sectionType := range sectionNameToType {
		sb.WriteString(fmt.Sprintf("\n\t%s %s", sectionName, sectionType))
	}
	sb.WriteString("\n}\n\n")

	// Accessors
	for sectionName := range sectionNameToType {
		methodName := toPublicName(sectionName)
		interfaceName := fmt.Sprintf("Translation_%s", methodName)
		sb.WriteString(fmt.Sprintf("func (t *%s) %s() %s {\n", rootStructName, methodName, interfaceName))
		sb.WriteString(fmt.Sprintf("\treturn &t.%s\n", sectionName))
		sb.WriteString("}\n\n")
	}

	hasParams := genFuncImpl(&sb, rootStructName, data.root)
	if hasParams {
		needsFmt = true
	}

	if needsFmt {
		header += "\nimport \"fmt\"\n"
	}
	stringContent := header + sb.String()
	formatted, err := formatCode(stringContent)
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func formatCode(src string) ([]byte, error) {
	formatted, err := format.Source([]byte(src))
	if err != nil {
		return nil, fmt.Errorf("error formatting code: \n\n---\n\n%s\n\n%w", src, err)
	}
	return formatted, nil
}

func GetBaseTranslation(baseTranslation TomlData, packageName string) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Code generated by simple-translate; DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Sections
	sectionNameToType := make(map[string]string)
	for sectionKey, sectionData := range baseTranslation.sections {
		sectionName := toPublicName(sectionKey)
		sectionTypeName := fmt.Sprintf("Translation_%s", sectionName)
		sectionNameToType[sectionName] = sectionTypeName

		sb.WriteString(fmt.Sprintf("type %s interface{\n", sectionTypeName))
		sortedKeys := getKeysSorted(sectionData)
		for index, key := range sortedKeys {
			value := sectionData[key]
			if index != 0 {
				sb.WriteString("\n")
			}
			sb.WriteString(fmt.Sprintf("// %s\n", strings.TrimSpace(value)))
			genFuncSignature(&sb, key, value)
		}
		sb.WriteString("}\n\n")
	}

	// Root
	sb.WriteString("type Translation interface{\n")
	for sectionName, sectionType := range sectionNameToType {
		sb.WriteString(fmt.Sprintf("\t%s() %s\n", sectionName, sectionType))
	}
	sb.WriteString("\n")
	sortedKeys := getKeysSorted(baseTranslation.root)
	for index, key := range sortedKeys {
		value := baseTranslation.root[key]
		if index != 0 {
			sb.WriteString("\n")
		}
		sb.WriteString(fmt.Sprintf("// \"%s\"\n", value))
		genFuncSignature(&sb, key, value)
	}
	sb.WriteString("}\n\n")

	formatted, err := formatCode(sb.String())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func GetTranslator(allLocales []string, packageName string, baseLocaleData TomlData) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Code generated by simple-translate; DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	sb.WriteString("import \"fmt\"\n\n")

	sb.WriteString("type Translator struct {\n")
	sb.WriteString("\tlangs map[string]Translation\n")
	sb.WriteString("\tcurrent Translation\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func New() *Translator {\n")
	sb.WriteString("\tt := &Translator{\n")
	sb.WriteString("\t\tlangs: make(map[string]Translation),\n")
	sb.WriteString("\t}\n\n")

	// Register all languages
	for index, lang := range allLocales {
		langName := toPublicName(lang)
		structName := fmt.Sprintf("Translation%s", langName)

		// Use first as default
		if index == 0 {
			sb.WriteString(fmt.Sprintf("\tt.current = &%s{}\n\n", structName))
		}

		sb.WriteString(fmt.Sprintf("\tt.langs[\"%s\"] = &%s{}\n", lang, structName))
	}

	sb.WriteString("\n\treturn t\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (t *Translator) SetLanguage(l string) error {\n")
	sb.WriteString("\ttranslation, exists := t.langs[l]\n")
	sb.WriteString("\tif !exists {\n")
	sb.WriteString("\t\treturn fmt.Errorf(\"language %s not found\", l)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tt.current = translation\n")
	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	// Forwarding methods for sections
	sectionNameToType := make(map[string]string)
	for sectionKey := range baseLocaleData.sections {
		sectionName := toPublicName(sectionKey)
		sectionType := fmt.Sprintf("Translation_%s", sectionName)
		sectionNameToType[sectionName] = sectionType
		sb.WriteString(fmt.Sprintf("func (t *Translator) %s() %s {\n", sectionName, sectionType))
		sb.WriteString("\treturn t.current." + sectionName + "()\n")
		sb.WriteString("}\n\n")
	}

	// Forwarding for root messages
	for rootKey := range baseLocaleData.root {
		rootMethod := toPublicName(rootKey)
		sb.WriteString(fmt.Sprintf("func (t *Translator) %s() string {\n", rootMethod))
		sb.WriteString("\treturn t.current." + rootMethod + "()\n")
		sb.WriteString("}\n\n")
	}

	formatted, err := formatCode(sb.String())
	if err != nil {
		return nil, err
	}

	return formatted, err
}

func toPublicName(name string) string {
	parts := strings.Split(name, "_")
	var result []string
	for _, part := range parts {
		if len(part) > 0 {
			result = append(result, capitalizeFirstLetter(part))
		}
	}
	return strings.Join(result, "")
}

func toPrivateName(name string) string {
	publicName := toPublicName(name)
	return strings.ToLower(publicName[:1]) + publicName[1:]
}

func capitalizeFirstLetter(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func getMethodDef(value string) ([]string, string) {
	tokens := tokenize(value)

	funcArgs := make([]string, 0)
	seenFuncArgs := make(map[string]bool)
	fmtArgs := make([]string, 0)

	var returnSingular strings.Builder
	var returnPlural strings.Builder

	hasPlural := false

	for _, token := range tokens {
		switch token.Type {
		case TokenText:
			// TODO(christoffer): Escape %
			returnSingular.WriteString(token.Value)
			returnPlural.WriteString(token.Value)
		case TokenSub:
			if !seenFuncArgs[token.Value] {
				if token.Value == "count" {
					funcArgs = append([]string{"count int"}, funcArgs...)
				} else {
					funcArgs = append(funcArgs, token.Value+" string")
				}
				seenFuncArgs[token.Value] = true
			}
			fmtArgs = append(fmtArgs, token.Value)
			placeholder := "%s"
			if token.Value == "count" {
				placeholder = "%d"
			}
			returnSingular.WriteString(placeholder)
			returnPlural.WriteString(placeholder)
		case TokenPlural:
			if !seenFuncArgs["count"] {
				funcArgs = append([]string{"count int"}, funcArgs...)
				seenFuncArgs["count"] = true
			}
			hasPlural = true
			// Split on |, singular first and plural second
			parts := strings.Split(token.Value, "|")
			singularForm := parts[0]
			var pluralForm string
			if len(parts) == 1 {
				singularForm = ""
				pluralForm = parts[0]
			} else {
				pluralForm = strings.Join(parts[1:], "")
			}
			returnSingular.WriteString(pluralForm)
			returnPlural.WriteString(singularForm)
		}
	}

	var body strings.Builder

	if hasPlural {
		body.WriteString("\tif count == 1 {\n")
		genSprintfReturn(&body, returnSingular.String(), fmtArgs)
		body.WriteString("\t} else {\n")
		genSprintfReturn(&body, returnPlural.String(), fmtArgs)
		body.WriteString("\t}\n")
	} else {
		genSprintfReturn(&body, returnSingular.String(), fmtArgs)
	}

	return funcArgs, body.String()
}

func genSprintfReturn(sb *strings.Builder, value string, subs []string) {
	fmtString := value
	for _, sub := range subs {
		placeholder := "%s"
		if sub == "count" {
			placeholder = "%d"
		}
		fmtString = strings.ReplaceAll(fmtString, fmt.Sprintf("{%s}", sub), placeholder)
	}

	fmtString = strconv.Quote(fmtString)

	if len(subs) > 0 {
		fmtArgs := strings.Join(subs, ", ")
		sb.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(%s, %s)\n", fmtString, fmtArgs))
	} else {
		sb.WriteString(fmt.Sprintf("\treturn %s\n", fmtString))
	}
}
