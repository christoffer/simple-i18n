package internal

import (
	"fmt"
	"go/format"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

type Substitution struct {
	key   string
	value string
}

func getKeysSorted(data map[string]string) []string {
	keys := make([]string, 0, len(data))
	for key := range data {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func genFuncImpl(sb *strings.Builder, name string, data map[string]string) bool {
	hasParams := false
	keys := getKeysSorted(data)
	for _, key := range keys {
		strValue := data[key]
		methodName := toPublicName(key)
		params, body := getMethodDef(strValue)
		sb.WriteString(fmt.Sprintf("func (t *%s) %s(%s) string {\n", name, methodName, strings.Join(params, ", ")))
		sb.WriteString(body)
		sb.WriteString("}\n\n")
		if len(params) > 0 {
			hasParams = true
		}
	}
	return hasParams
}

func genFuncSignature(sb *strings.Builder, structName string, data map[string]string) {
	keys := getKeysSorted(data)
	for _, key := range keys {
		strValue := data[key]
		funcName := toPublicName(key)
		params, _ := getMethodDef(strValue)
		if structName == "" {
			sb.WriteString(fmt.Sprintf("%s(%s) string\n", funcName, strings.Join(params, ", ")))
		} else {
			sb.WriteString(fmt.Sprintf("func (_ *%s) %s(%s) string\n", structName, funcName, strings.Join(params, ", ")))
		}
	}
}

func GetTranslationImpl(data TomlData, packageName string) ([]byte, error) {
	var sb strings.Builder

	header := fmt.Sprintf(`
	  // Code generated by simple-translate; DO NOT EDIT.
	  package %s
	`, packageName)
	needsFmt := false

	// Write all sections first
	sectionNameToType := make(map[string]string)
	for sectionKey, sectionData := range data.sections {
		sectionName := toPrivateName(sectionKey)
		langName := toPublicName(data.Locale)
		sectionStructName := fmt.Sprintf("Translation%s_%s", langName, sectionName)
		sectionNameToType[sectionName] = sectionStructName

		sb.WriteString(fmt.Sprintf("type %s struct{}\n\n", sectionStructName))
		hasParams := genFuncImpl(&sb, sectionStructName, sectionData)
		if hasParams {
			needsFmt = true
		}
	}

	// Root translations
	langName := toPublicName(data.Locale)
	rootStructName := fmt.Sprintf("Translation%s", langName)
	sb.WriteString(fmt.Sprintf("type %s struct{", rootStructName))
	for sectionName, sectionType := range sectionNameToType {
		sb.WriteString(fmt.Sprintf("\n\t%s %s", sectionName, sectionType))
	}
	sb.WriteString("\n}\n\n")

	// Accessors
	for sectionName := range sectionNameToType {
		methodName := toPublicName(sectionName)
		interfaceName := fmt.Sprintf("Translation_%s", methodName)
		sb.WriteString(fmt.Sprintf("func (t *%s) %s() %s {\n", rootStructName, methodName, interfaceName))
		sb.WriteString(fmt.Sprintf("\treturn &t.%s\n", sectionName))
		sb.WriteString("}\n\n")
	}

	hasParams := genFuncImpl(&sb, rootStructName, data.root)
	if hasParams {
		needsFmt = true
	}

	if needsFmt {
		header += "\nimport \"fmt\"\n"
	}
	stringContent := header + sb.String()
	formatted, err := formatCode(stringContent)
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func formatCode(src string) ([]byte, error) {
	formatted, err := format.Source([]byte(src))
	if err != nil {
		return nil, fmt.Errorf("error formatting code: \n\n---\n\n%s\n\n%w", src, err)
	}
	return formatted, nil
}

func GetBaseTranslation(baseTranslation TomlData, packageName string) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Code generated by simple-translate; DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Sections
	sectionNameToType := make(map[string]string)
	for sectionKey, sectionData := range baseTranslation.sections {
		sectionName := toPublicName(sectionKey)
		sectionTypeName := fmt.Sprintf("Translation_%s", sectionName)
		sectionNameToType[sectionName] = sectionTypeName

		sb.WriteString(fmt.Sprintf("type %s interface{\n\n", sectionTypeName))
		genFuncSignature(&sb, "", sectionData)
		sb.WriteString("}\n\n")
	}

	// Root
	sb.WriteString("type Translation interface{\n")
	for sectionName, sectionType := range sectionNameToType {
		sb.WriteString(fmt.Sprintf("\t%s() %s\n", sectionName, sectionType))
	}
	sb.WriteString("\n")
	genFuncSignature(&sb, "", baseTranslation.root)
	sb.WriteString("}\n\n")

	formatted, err := formatCode(sb.String())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func GetTranslator(allLangs []string, packageName string, baseLocaleData TomlData) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Code generated by simple-translate; DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	sb.WriteString("import \"fmt\"\n\n")

	sb.WriteString("type Translator struct {\n")
	sb.WriteString("\tlangs map[string]Translation\n")
	sb.WriteString("\tcurrent Translation\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func New() *Translator {\n")
	sb.WriteString("\tt := &Translator{\n")
	sb.WriteString("\t\tlangs: make(map[string]Translation),\n")
	sb.WriteString("\t}\n\n")

	// Register all languages
	for index, lang := range allLangs {
		langName := toPublicName(lang)
		structName := fmt.Sprintf("Translation%s", langName)

		// Use first as default
		if index == 0 {
			sb.WriteString(fmt.Sprintf("\tt.current = &%s{}\n\n", structName))
		}

		sb.WriteString(fmt.Sprintf("\tt.langs[\"%s\"] = &%s{}\n", lang, structName))
	}

	sb.WriteString("\n\treturn t\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (t *Translator) SetLanguage(l string) error {\n")
	sb.WriteString("\ttranslation, exists := t.langs[l]\n")
	sb.WriteString("\tif !exists {\n")
	sb.WriteString("\t\treturn fmt.Errorf(\"language %s not found\", l)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tt.current = translation\n")
	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	// Forwarding methods for sections
	sectionNameToType := make(map[string]string)
	for sectionKey := range baseLocaleData.sections {
		sectionName := toPublicName(sectionKey)
		sectionType := fmt.Sprintf("Translation_%s", sectionName)
		sectionNameToType[sectionName] = sectionType
		sb.WriteString(fmt.Sprintf("func (t *Translator) %s() %s {\n", sectionName, sectionType))
		sb.WriteString("\treturn t.current." + sectionName + "()\n")
		sb.WriteString("}\n\n")
	}

	// Forwarding for root messages
	for rootKey := range baseLocaleData.root {
		rootMethod := toPublicName(rootKey)
		sb.WriteString(fmt.Sprintf("func (t *Translator) %s() string {\n", rootMethod))
		sb.WriteString("\treturn t.current." + rootMethod + "()\n")
		sb.WriteString("}\n\n")
	}

	formatted, err := formatCode(sb.String())
	if err != nil {
		return nil, err
	}

	return formatted, err
}

func toPublicName(name string) string {
	parts := strings.Split(name, "_")
	var result []string
	for _, part := range parts {
		if len(part) > 0 {
			result = append(result, capitalizeFirstLetter(part))
		}
	}
	return strings.Join(result, "")
}

func toPrivateName(name string) string {
	publicName := toPublicName(name)
	return strings.ToLower(publicName[:1]) + publicName[1:]
}

func capitalizeFirstLetter(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func getMethodDef(value string) ([]string, string) {
	var body strings.Builder

	pluralRegex := regexp.MustCompile(`\{\{(\w*)\}\}`)
	hasPlural := pluralRegex.MatchString(value)

	substRegex := regexp.MustCompile(`\{(\w+)\}`)
	// Search for subs in the string excluding plurals to avoid matching 'dog{{s}}' as a '{<sub s>}'
	valueNoPlurals := pluralRegex.ReplaceAllString(value, "")
	subMatches := substRegex.FindAllStringSubmatch(valueNoPlurals, -1)
	subs := make([]string, 0)
	for _, match := range subMatches {
		name := match[1]
		subs = append(subs, name)
	}

	params := make([]string, 0)
	seenParams := make(map[string]bool)
	if hasPlural {
		// Count is always first
		params = append(params, "count")
		seenParams["count"] = true
	}

	for _, sub := range subs {
		if _, exists := seenParams[sub]; !exists {
			params = append(params, sub)
			seenParams[sub] = true
		}
	}

	if hasPlural {
		body.WriteString("\tif count == 1 {\n")
		// Singular case
		genSprintfReturn(&body, valueNoPlurals, subs)
		body.WriteString("\t}\n")

		// Plural case

		// Generate plural return - replace all {{...}} with their contents
		valueNoSingluars := pluralRegex.ReplaceAllString(value, "$1")
		genSprintfReturn(&body, valueNoSingluars, subs)
	} else {
		genSprintfReturn(&body, value, subs)
	}

	var paramList []string
	for _, name := range params {
		paramType := "string"
		if name == "count" {
			paramType = "int"
		}
		paramList = append(paramList, fmt.Sprintf("%s %s", name, paramType))
	}
	return paramList, body.String()
}

func genSprintfReturn(sb *strings.Builder, value string, subs []string) {
	fmtString := value
	for _, sub := range subs {
		placeholder := "%s"
		if sub == "count" {
			placeholder = "%d"
		}
		fmtString = strings.ReplaceAll(fmtString, fmt.Sprintf("{%s}", sub), placeholder)
	}

	fmtString = strconv.Quote(fmtString)

	if len(subs) > 0 {
		fmtArgs := strings.Join(subs, ", ")
		sb.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(%s, %s)\n", fmtString, fmtArgs))
	} else {
		sb.WriteString(fmt.Sprintf("\treturn %s\n", fmtString))
	}
}
