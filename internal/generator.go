package internal

import (
	"fmt"
	"go/format"
	"sort"
	"strconv"
	"strings"
)

type Substitution struct {
	key   string
	value string
}

func getKeysSorted(data map[string]TranslateFunc) []string {
	keys := make([]string, 0, len(data))
	for key := range data {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func genFuncImplementations(sb *strings.Builder, structName string, trFuncs map[string]TranslateFunc) error {
	keys := getKeysSorted(trFuncs)
	for _, key := range keys {
		trFunc := trFuncs[key]
		sb.WriteString(fmt.Sprintf("func (t *%s) %s(%s) string {\n", structName, trFunc.Name, strings.Join(trFunc.Params, ", ")))
		sb.WriteString(trFunc.Body)
		sb.WriteString("}\n\n")
	}
	return nil
}

func GetTranslationImpl(data TomlParseResult, packageName string) ([]byte, error) {
	var sb strings.Builder

	header := fmt.Sprintf(`
	  // Code generated by simple-translate; DO NOT EDIT.
	  package %s
	`, packageName)

	// Write all sections first
	sectionNameToType := make(map[string]string)
	for sectionKey, sectionData := range data.sections {
		sectionName := toPrivateName(sectionKey)
		langName := toPublicName(data.Locale)
		sectionStructName := fmt.Sprintf("Translation%s_%s", langName, sectionName)
		sectionNameToType[sectionName] = sectionStructName

		sb.WriteString(fmt.Sprintf("type %s struct{}\n\n", sectionStructName))
		if err := genFuncImplementations(&sb, sectionStructName, sectionData); err != nil {
			return nil, err
		}
	}

	// Root translations
	langName := toPublicName(data.Locale)
	rootStructName := fmt.Sprintf("Translation%s", langName)
	sb.WriteString(fmt.Sprintf("type %s struct{", rootStructName))
	for sectionName, sectionType := range sectionNameToType {
		sb.WriteString(fmt.Sprintf("\n\t%s %s", sectionName, sectionType))
	}
	sb.WriteString("\n}\n\n")

	// Accessors
	for sectionName := range sectionNameToType {
		methodName := toPublicName(sectionName)
		interfaceName := fmt.Sprintf("Translation_%s", methodName)
		sb.WriteString(fmt.Sprintf("func (t *%s) %s() %s {\n", rootStructName, methodName, interfaceName))
		sb.WriteString(fmt.Sprintf("\treturn &t.%s\n", sectionName))
		sb.WriteString("}\n\n")
	}

	if err := genFuncImplementations(&sb, rootStructName, data.root); err != nil {
		return nil, err
	}

	header += "\nimport \"fmt\"\n"

	stringContent := header + sb.String()
	formatted, err := formatCode(stringContent)
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func formatCode(src string) ([]byte, error) {
	formatted, err := format.Source([]byte(src))
	if err != nil {
		return nil, fmt.Errorf("error formatting code: \n\n---\n\n%s\n\n%w", src, err)
	}
	return formatted, nil
}

func GetBaseTranslation(baseTranslation TomlParseResult, packageName string) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Code generated by simple-translate; DO NOT EDIT.\n\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Sections
	sectionNameToType := make(map[string]string)
	for sectionKey, sectionData := range baseTranslation.sections {
		sectionName := toPublicName(sectionKey)
		sectionTypeName := fmt.Sprintf("Translation_%s", sectionName)
		sectionNameToType[sectionName] = sectionTypeName

		sb.WriteString(fmt.Sprintf("type %s interface{\n", sectionTypeName))
		sortedKeys := getKeysSorted(sectionData)
		for index, key := range sortedKeys {
			trFunc := sectionData[key]
			if index != 0 {
				sb.WriteString("\n")
			}
			sb.WriteString(trFunc.DocString + "\n")
			sb.WriteString(trFunc.Signature() + "\n")
		}
		sb.WriteString("}\n\n")
	}

	// Root
	sb.WriteString("type Translation interface{\n")
	for sectionName, sectionType := range sectionNameToType {
		sb.WriteString(fmt.Sprintf("\t%s() %s\n", sectionName, sectionType))
	}
	sb.WriteString("\n")
	sortedKeys := getKeysSorted(baseTranslation.root)
	for index, key := range sortedKeys {
		trFunc := baseTranslation.root[key]
		if index != 0 {
			sb.WriteString("\n")
		}
		sb.WriteString(fmt.Sprintf("// \"%s\"\n", trFunc.DocString))
		sb.WriteString(trFunc.Signature())
	}
	sb.WriteString("}\n\n")

	formatted, err := formatCode(sb.String())
	if err != nil {
		return nil, err
	}

	return formatted, nil
}

func GetTranslator(allLocales []string, packageName string, baseLocaleData TomlParseResult) ([]byte, error) {
	var sb strings.Builder
	sb.WriteString("// Code generated by simple-translate; DO NOT EDIT.\n")
	sb.WriteString(fmt.Sprintf("package %s\n\n", packageName))
	sb.WriteString("import \"fmt\"\n\n")

	sb.WriteString("type Translator struct {\n")
	sb.WriteString("\tlangs map[string]Translation\n")
	sb.WriteString("\tcurrent Translation\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func New() *Translator {\n")
	sb.WriteString("\tt := &Translator{\n")
	sb.WriteString("\t\tlangs: make(map[string]Translation),\n")
	sb.WriteString("\t}\n\n")

	// Register all languages
	for index, lang := range allLocales {
		langName := toPublicName(lang)
		structName := fmt.Sprintf("Translation%s", langName)

		// Use first as default
		if index == 0 {
			sb.WriteString(fmt.Sprintf("\tt.current = &%s{}\n\n", structName))
		}

		sb.WriteString(fmt.Sprintf("\tt.langs[\"%s\"] = &%s{}\n", lang, structName))
	}

	sb.WriteString("\n\treturn t\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (t *Translator) SetLanguage(l string) error {\n")
	sb.WriteString("\ttranslation, exists := t.langs[l]\n")
	sb.WriteString("\tif !exists {\n")
	sb.WriteString("\t\treturn fmt.Errorf(\"language %s not found\", l)\n")
	sb.WriteString("\t}\n")
	sb.WriteString("\tt.current = translation\n")
	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n\n")

	// Forwarding methods for sections
	sectionNameToType := make(map[string]string)
	for sectionKey := range baseLocaleData.sections {
		sectionName := toPublicName(sectionKey)
		sectionType := fmt.Sprintf("Translation_%s", sectionName)
		sectionNameToType[sectionName] = sectionType
		sb.WriteString(fmt.Sprintf("func (t *Translator) %s() %s {\n", sectionName, sectionType))
		sb.WriteString("\treturn t.current." + sectionName + "()\n")
		sb.WriteString("}\n\n")
	}

	// Forwarding for root messages
	for rootKey := range baseLocaleData.root {
		rootMethod := toPublicName(rootKey)
		sb.WriteString(fmt.Sprintf("func (t *Translator) %s() string {\n", rootMethod))
		sb.WriteString("\treturn t.current." + rootMethod + "()\n")
		sb.WriteString("}\n\n")
	}

	formatted, err := formatCode(sb.String())
	if err != nil {
		return nil, err
	}

	return formatted, err
}

func toPublicName(name string) string {
	parts := strings.Split(name, "_")
	var result []string
	for _, part := range parts {
		if len(part) > 0 {
			result = append(result, capitalizeFirstLetter(part))
		}
	}
	return strings.Join(result, "")
}

func toPrivateName(name string) string {
	publicName := toPublicName(name)
	return strings.ToLower(publicName[:1]) + publicName[1:]
}

func capitalizeFirstLetter(s string) string {
	if len(s) == 0 {
		return s
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func genSprintfReturn(sb *strings.Builder, value string, fmtArgs []string) {
	fmtString := value
	fmtString = strconv.Quote(fmtString)
	// NOTE(christoffer): We could technically return the value directly if there are no format args.
	// However, use Sprintf() always since the fmtString potentially contains escaped characters.
	argPart := ""
	if len(fmtArgs) > 0 {
		argPart = ", " + strings.Join(fmtArgs, ", ")
	}
	sb.WriteString(fmt.Sprintf("\treturn fmt.Sprintf(%s%s)\n", fmtString, argPart))
}
